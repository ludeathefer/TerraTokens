package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"time"

	"github.com/google/uuid"
	"github.com/ludeathfer/TerraTokens/backend/graph/model"
	"github.com/ludeathfer/TerraTokens/backend/middleware"
	blockchain "github.com/ludeathfer/TerraTokens/backend/pkg/go-eth"
	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	db := r.Database

	// Start a transaction
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to start transaction: %w", err)
	}

	// Ensure rollback on error
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// Generate new UUID for user
	id := uuid.New()

	// Insert the user
	query := `
		INSERT INTO users (id, public_key, username, phone, email, password)
		VALUES (?, ?, ?, ?, ?, ?)
	`
	_, err = tx.ExecContext(ctx, query, id.String(), input.PublicKey, input.Username, input.Phone, input.Email, hashedPassword)
	if err != nil {
		return nil, fmt.Errorf("failed to insert user: %w", err)
	}

	// Fetch the 'user' role
	role := &model.Role{}
	query = `SELECT id, name, description FROM roles WHERE name = 'user'`
	err = tx.QueryRowContext(ctx, query).Scan(&role.ID, &role.Name, &role.Description)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user role: %w", err)
	}

	// Assign the 'user' role to the new user
	query = `INSERT INTO user_roles (user_id, role_id) VALUES (?, ?)`
	_, err = tx.ExecContext(ctx, query, id.String(), role.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to assign user role: %w", err)
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Return the created user object
	user := &model.User{
		ID:        id,
		PublicKey: input.PublicKey,
		Username:  input.Username,
		Phone:     input.Phone,
		Email:     input.Email,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
		Roles:     []*model.Role{role},
	}
	return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id uuid.UUID, input model.UpdateUserInput) (*model.User, error) {
	db := r.Database

	// Start a transaction
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to start transaction: %w", err)
	}

	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Update query
	query := `
		UPDATE users 
		SET updated_at = NOW()
		`
	args := []any{}

	if input.Username != nil {
		query += ", username = ?"
		args = append(args, input.Username)
	}

	if input.Phone != nil {
		query += ", phone = ?"
		args = append(args, input.Phone)
	}

	if input.Email != nil {
		query += ", email = ?"
		args = append(args, input.Email)
	}

	// Append password update only if provided
	if input.Password != nil {
		password := *input.Password

		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", err)
		}

		query += ", password = ?"
		args = append(args, hashedPassword)
	}

	query += " WHERE id = ?"
	args = append(args, id.String())

	// Execute update
	result, err := tx.ExecContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return nil, fmt.Errorf("failed to check affected rows: %w", err)
	}

	if rowsAffected == 0 {
		return nil, fmt.Errorf("user not found")
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	user := &model.User{
		ID:       id,
		Username: *input.Username,
		Phone:    *input.Phone,
		Email:    *input.Email,
	}

	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id uuid.UUID) (bool, error) {
	db := r.Database

	query := `DELETE FROM users WHERE id = ?`
	result, err := db.ExecContext(ctx, query, id.String())
	if err != nil {
		return false, fmt.Errorf("failed to delete user: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return false, fmt.Errorf("failed to check affected rows: %w", err)
	}

	if rowsAffected == 0 {
		return false, fmt.Errorf("user not found")
	}

	return true, nil
}

// CreateLandToken is the resolver for the createLandToken field.
func (r *mutationResolver) CreateLandToken(ctx context.Context, privateKey string, input model.CreateLandTokenInput) (*model.LandToken, error) {
	db := r.Database
	bcc := r.BlockchainClient

	transactor, err := blockchain.CreateTransactor(ctx, bcc.Client, privateKey)
	if err != nil {
		return nil, fmt.Errorf("failed creating transactor: %v", err)
	}

	tx, err := bcc.Land.FractionalizeLand(transactor, "", big.NewInt(int64(input.TotalTokens)))
	if err != nil {
		return nil, fmt.Errorf("failed sending transaction: %v", err)
	}

	log.Printf("FractionalizeLand Transaction sent: %s", tx.Hash().Hex())

	eventLog, err := blockchain.WaitForEvent(ctx, bcc, tx.Hash().Hex())
	if err != nil {
		return nil, err
	}

	landIDBigInt := new(big.Int).SetBytes(eventLog.Topics[1].Bytes())
	landID := int32(landIDBigInt.Int64())

	// Generate new UUID
	landTokenID := uuid.New()

	// Insert data into DB
	query := `
			INSERT INTO land_tokens (
				id, land_id, name, total_tokens, current_price, 
				property_type, property_size, property_size_unit, landmark, 
				distance_from_landmark, distance_unit, property_description, 
				latitude, longitude
			) 
			VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
		`
	_, err = db.Exec(query,
		landTokenID, landID, input.Name, input.TotalTokens, input.CurrentPrice,
		input.PropertyType, input.PropertySize, input.PropertySizeUnit, input.Landmark,
		input.DistanceFromLandmark, input.DistanceUnit, input.PropertyDescription,
		input.Latitude, input.Longitude,
	)
	if err != nil {
		return nil, fmt.Errorf("failed inserting into database: %v", err)
	}

	// Construct response object
	landToken := &model.LandToken{
		ID:                   landTokenID,
		LandID:               landID,
		Name:                 input.Name,
		TotalTokens:          input.TotalTokens,
		CreatedAt:            time.Now(),
		UpdatedAt:            time.Now(),
		CurrentPrice:         input.CurrentPrice,
		PropertyType:         input.PropertyType,
		PropertySize:         input.PropertySize,
		PropertySizeUnit:     input.PropertySizeUnit,
		Landmark:             input.Landmark,
		DistanceFromLandmark: input.DistanceFromLandmark,
		DistanceUnit:         input.DistanceUnit,
		PropertyDescription:  input.PropertyDescription,
		Latitude:             input.Latitude,
		Longitude:            input.Longitude,
	}

	return landToken, nil
}

// UpdateLandToken is the resolver for the updateLandToken field.
func (r *mutationResolver) UpdateLandToken(ctx context.Context, id uuid.UUID, input model.CreateLandTokenInput) (*model.LandToken, error) {
	panic(fmt.Errorf("not implemented: UpdateLandToken - updateLandToken"))
}

// AddPriceToLandToken is the resolver for the addPriceToLandToken field.
func (r *mutationResolver) AddPriceToLandToken(ctx context.Context, landTokenID uuid.UUID, input model.CreatePriceInput) (*model.LandToken, error) {
	panic(fmt.Errorf("not implemented: AddPriceToLandToken - addPriceToLandToken"))
}

// BuyToken is the resolver for the buyToken field.
func (r *mutationResolver) BuyToken(ctx context.Context, privateKey string, input model.BuyTokenInput) (*model.TransactedToken, error) {
	panic(fmt.Errorf("not implemented: BuyToken - buyToken"))
}

// CreateSale is the resolver for the createSale field.
func (r *mutationResolver) CreateSale(ctx context.Context, privateKey string, input model.CreateSaleInput) (*model.Sale, error) {
	panic(fmt.Errorf("not implemented: CreateSale - createSale"))
}

// DeleteSale is the resolver for the deleteSale field.
func (r *mutationResolver) DeleteSale(ctx context.Context, privateKey string, id int) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteSale - deleteSale"))
}

// AddToWatchlist is the resolver for the addToWatchlist field.
func (r *mutationResolver) AddToWatchlist(ctx context.Context, landTokenID uuid.UUID) (*model.User, error) {
	panic(fmt.Errorf("not implemented: AddToWatchlist - addToWatchlist"))
}

// RemoveFromWatchlist is the resolver for the removeFromWatchlist field.
func (r *mutationResolver) RemoveFromWatchlist(ctx context.Context, landTokenID uuid.UUID) (*model.User, error) {
	panic(fmt.Errorf("not implemented: RemoveFromWatchlist - removeFromWatchlist"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	db := r.Database

	query :=
		`		
		select u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
		r.id, r.name, r.description
		from users u
		left join user_roles ur on u.id = ur.user_id
		left join roles r on ur.role_id = r.id
		`

	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch users: %w", err)
	}
	defer rows.Close()

	userMap := make(map[uuid.UUID]*model.User)

	for rows.Next() {
		user := &model.User{}
		role := &model.Role{}

		err := rows.Scan(&user.ID, &user.PublicKey, &user.Username, &user.Phone, &user.Email, &user.CreatedAt, &user.UpdatedAt, &role.ID, &role.Name, &role.Description)
		if err != nil {
			return nil, fmt.Errorf("failed to scan user: %w", err)
		}

		if _, exists := userMap[user.ID]; !exists {
			userMap[user.ID] = user
		}

		userMap[user.ID].Roles = append(userMap[user.ID].Roles, role)
	}

	users := make([]*model.User, 0, len(userMap))
	for _, user := range userMap {
		users = append(users, user)
	}

	return users, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id uuid.UUID) (*model.User, error) {
	db := r.Database

	query := `
		SELECT 
			u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
			r.id, r.name, r.description
		FROM users u
		LEFT JOIN user_roles ur ON u.id = ur.user_id
		LEFT JOIN roles r ON ur.role_id = r.id
		WHERE u.id = ?
	`

	rows, err := db.QueryContext(ctx, query, id.String())
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user: %w", err)
	}
	defer rows.Close()

	var user *model.User

	for rows.Next() {
		user = &model.User{}
		role := &model.Role{}
		err := rows.Scan(&user.ID, &user.PublicKey, &user.Username, &user.Email, &user.Phone, &user.CreatedAt, &user.UpdatedAt, &role.ID, &role.Name, &role.Description)
		if err != nil {
			return nil, fmt.Errorf("failed to scan user: %w", err)
		}
		user.Roles = append(user.Roles, role)
	}

	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	return user, nil
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, email string, password string) (*model.LoginResponse, error) {
	db := r.Database

	query := `
			SELECT
				u.id, u.public_key, u.username, u.phone, u.email, u.password, u.created_at, u.updated_at,
				r.id, r.name, r.description
			FROM users u
			LEFT JOIN user_roles ur ON u.id = ur.user_id
			LEFT JOIN roles r ON ur.role_id = r.id
			WHERE u.email = ?
		`
	rows, err := db.QueryContext(ctx, query, email)
	if err != nil {
		return nil, fmt.Errorf("invalid credentials: %w", err)
	}
	defer rows.Close()

	var user *model.User
	roleNames := []string{}
	for rows.Next() {
		user = &model.User{}
		role := &model.Role{}
		err := rows.Scan(&user.ID, &user.PublicKey, &user.Username, &user.Email, &user.Phone, &user.Password, &user.CreatedAt, &user.UpdatedAt, &role.ID, &role.Name, &role.Description)
		if err != nil {
			return nil, fmt.Errorf("failed to scan user: %w", err)
		}
		user.Roles = append(user.Roles, role)
		roleNames = append(roleNames, role.Name)
	}

	if user == nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	token, err := middleware.GenerateToken(r.Config.JWT, user.ID, roleNames)
	if err != nil {
		return nil, err
	}

	loginResponse := &model.LoginResponse{
		Token: token,
		User:  user,
	}

	return loginResponse, nil
}

// LandTokens is the resolver for the landTokens field.
func (r *queryResolver) LandTokens(ctx context.Context) ([]*model.LandToken, error) {
	panic(fmt.Errorf("not implemented: LandTokens - landTokens"))
}

// LandToken is the resolver for the landToken field.
func (r *queryResolver) LandToken(ctx context.Context, id uuid.UUID) (*model.LandToken, error) {
	panic(fmt.Errorf("not implemented: LandToken - landToken"))
}

// Sales is the resolver for the sales field.
func (r *queryResolver) Sales(ctx context.Context) ([]*model.Sale, error) {
	panic(fmt.Errorf("not implemented: Sales - sales"))
}

// Sale is the resolver for the sale field.
func (r *queryResolver) Sale(ctx context.Context, id int) (*model.Sale, error) {
	panic(fmt.Errorf("not implemented: Sale - sale"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
