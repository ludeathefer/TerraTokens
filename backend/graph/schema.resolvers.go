package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/ludeathfer/TerraTokens/backend/graph/model"
	"github.com/ludeathfer/TerraTokens/backend/middleware"
	"golang.org/x/crypto/bcrypt"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	db := r.Database

	// Start a transaction
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to start transaction: %w", err)
	}

	// Ensure rollback on error
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	// Insert the user
	query := `
		INSERT INTO users (public_key, username, phone, email)
		VALUES (?, ?, ?, ?)
	`
	_, err = tx.ExecContext(ctx, query, input.PublicKey, input.Username, input.Phone, input.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to insert user: %w", err)
	}

	// Fetch the 'user' role
	role := &model.Role{}
	query = `SELECT id, name, description FROM roles WHERE name = 'user'`
	err = tx.QueryRowContext(ctx, query).Scan(&role.ID, &role.Name, &role.Description)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user role: %w", err)
	}

	// Assign the 'user' role to the new user
	query = `INSERT INTO user_roles (user_public_key, role_id) VALUES (?, ?)`
	_, err = tx.ExecContext(ctx, query, input.PublicKey, role.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to assign user role: %w", err)
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Return the created user object
	user := &model.User{
		PublicKey: input.PublicKey,
		Username:  input.Username,
		Phone:     input.Phone,
		Email:     input.Email,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
		Roles:     []*model.Role{role},
	}
	return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, publicKey string, input model.UpdateUserInput) (*model.User, error) {
	db := r.Database

	// Start a transaction
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to start transaction: %w", err)
	}

	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Update query
	query := `
		UPDATE users 
		SET updated_at = NOW()
		`
	args := []any{}

	if input.Username != nil {
		query += ", username = ?"
		args = append(args, input.Username)
	}

	if input.Phone != nil {
		query += ", phone = ?"
		args = append(args, input.Phone)
	}

	if input.Email != nil {
		query += ", email = ?"
		args = append(args, input.Email)
	}

	// Append password update only if provided
	if input.Password != nil {
		password := *input.Password

		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %w", err)
		}

		query += ", password = ?"
		args = append(args, hashedPassword)
	}

	query += " WHERE public_key = ?"
	args = append(args, publicKey)

	// Execute update
	result, err := tx.ExecContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return nil, fmt.Errorf("failed to check affected rows: %w", err)
	}

	if rowsAffected == 0 {
		return nil, fmt.Errorf("user not found")
	}

	// Commit transaction
	if err = tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	user := &model.User{
		Username: *input.Username,
		Phone:    *input.Phone,
		Email:    *input.Email,
	}

	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, publicKey string) (bool, error) {
	db := r.Database

	query := `DELETE FROM users WHERE public_key = ?`
	result, err := db.ExecContext(ctx, query, publicKey)
	if err != nil {
		return false, fmt.Errorf("failed to delete user: %w", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return false, fmt.Errorf("failed to check affected rows: %w", err)
	}

	if rowsAffected == 0 {
		return false, fmt.Errorf("user not found")
	}

	return true, nil
}

// CreateLandToken is the resolver for the createLandToken field.
func (r *mutationResolver) CreateLandToken(ctx context.Context, input model.CreateLandTokenInput) (*model.LandToken, error) {
	db := r.Database

	query := `
	UPDATE land_tokens
	SET
		current_price = ?,
		property_type = ?,
		property_size = ?,
		property_size_unit = ?,
		landmark = ?,
		distance_from_landmark = ?,
		distance_unit = ?,
		property_description = ?,
		latitude = ?,
		longitude = ?
	WHERE
    	name = ?;
		`
	_, err := db.ExecContext(ctx, query,
		input.CurrentPrice,
		input.PropertyType, input.PropertySize, input.PropertySizeUnit, input.Landmark,
		input.DistanceFromLandmark, input.DistanceUnit, input.PropertyDescription,
		input.Latitude, input.Longitude, input.Name,
	)

	if err != nil {
		return nil, fmt.Errorf("failed inserting into database: %v", err)
	}

	// Construct response object
	landToken := &model.LandToken{
		Name:                 input.Name,
		CreatedAt:            time.Now(),
		UpdatedAt:            time.Now(),
		CurrentPrice:         input.CurrentPrice,
		PropertyType:         input.PropertyType,
		PropertySize:         input.PropertySize,
		PropertySizeUnit:     input.PropertySizeUnit,
		Landmark:             input.Landmark,
		DistanceFromLandmark: input.DistanceFromLandmark,
		DistanceUnit:         input.DistanceUnit,
		PropertyDescription:  input.PropertyDescription,
		Latitude:             input.Latitude,
		Longitude:            input.Longitude,
	}

	return landToken, nil
}

// UpdateLandToken is the resolver for the updateLandToken field.
func (r *mutationResolver) UpdateLandToken(ctx context.Context, publicKey string, input model.CreateLandTokenInput) (*model.LandToken, error) {
	panic(fmt.Errorf("not implemented: UpdateLandToken - updateLandToken"))
}

// AddPriceToLandToken is the resolver for the addPriceToLandToken field.
func (r *mutationResolver) AddPriceToLandToken(ctx context.Context, landID int32, input model.CreatePriceInput) (*model.LandToken, error) {

	db := r.Database

	// Check if the land token exists
	var exists bool
	err := db.QueryRowContext(ctx, "SELECT EXISTS(SELECT 1 FROM land_tokens WHERE land_id = ?)", landID).Scan(&exists)
	if err != nil {
		return nil, fmt.Errorf("failed to check if land token exists: %w", err)
	}
	if !exists {
		return nil, fmt.Errorf("land token with ID %d not found", landID)
	}

	// Insert the new price
	_, err = db.ExecContext(ctx, "INSERT INTO prices (land_token_id, value) VALUES (?, ?)", landID, input.Value)
	if err != nil {
		return nil, fmt.Errorf("failed to insert new price: %w", err)
	}

	// Update the current price in the land_tokens table
	_, err = db.ExecContext(ctx, "UPDATE land_tokens SET current_price = ?, updated_at = ? WHERE land_id = ?", input.Value, time.Now(), landID)
	if err != nil {
		return nil, fmt.Errorf("failed to update current price of land token: %w", err)
	}

	// Fetch the updated land token with its prices
	landToken, err := r.Query().LandToken(ctx, landID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated land token: %w", err)
	}

	return landToken, nil
}

// AddToWatchlist is the resolver for the addToWatchlist field.
func (r *mutationResolver) AddToWatchlist(ctx context.Context, publicKey string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: AddToWatchlist - addToWatchlist"))
}

// RemoveFromWatchlist is the resolver for the removeFromWatchlist field.
func (r *mutationResolver) RemoveFromWatchlist(ctx context.Context, publicKey string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: RemoveFromWatchlist - removeFromWatchlist"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	panic(fmt.Errorf("not implemented: Users - users"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, publicKey string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, publicKey string) (*model.LoginResponse, error) {
	db := r.Database

	query := `
		SELECT
			u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
			r.id, r.name, r.description
		FROM users u
		LEFT JOIN user_roles ur ON u.public_key = ur.user_public_key
		LEFT JOIN roles r ON ur.role_id = r.id
		WHERE u.public_key = ?
	`
	rows, err := db.QueryContext(ctx, query, publicKey)
	if err != nil {
		return nil, fmt.Errorf("invalid credentials: %w", err)
	}
	defer rows.Close()

	var user *model.User
	roleNames := []string{}
	for rows.Next() {
		user = &model.User{}
		role := &model.Role{}
		err := rows.Scan(&user.PublicKey, &user.Username, &user.Email, &user.Phone, &user.CreatedAt, &user.UpdatedAt, &role.ID, &role.Name, &role.Description)
		if err != nil {
			return nil, fmt.Errorf("failed to scan user: %w", err)
		}
		user.Roles = append(user.Roles, role)
		roleNames = append(roleNames, role.Name)
	}

	if user == nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	token, err := middleware.GenerateToken(r.Config.JWT, user.PublicKey, roleNames)
	if err != nil {
		return nil, err
	}

	loginResponse := &model.LoginResponse{
		Token: token,
		User:  user,
	}

	return loginResponse, nil
}

// LandTokens is the resolver for the landTokens field.
func (r *queryResolver) LandTokens(ctx context.Context) ([]*model.LandToken, error) {
	db := r.Database // Assuming r.Database is your *sql.DB

	query := `
		SELECT land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
		FROM land_tokens;
	`

	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query land tokens: %w", err)
	}
	defer rows.Close()

	var landTokens []*model.LandToken
	for rows.Next() {
		lt := &model.LandToken{}
		err := rows.Scan(
			&lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
			&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
			&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan land token: %w", err)
		}

		// Fetch prices for the land token
		query := `
					SELECT id, date, value
					FROM prices
					WHERE land_token_id = ?;
	`

		rows, err := db.QueryContext(ctx, query, lt.LandID)
		if err != nil {
			return nil, fmt.Errorf("failed to query prices: %w", err)
		}
		defer rows.Close()

		var prices []*model.Price
		for rows.Next() {
			p := &model.Price{}
			err := rows.Scan(&p.ID, &p.Date, &p.Value)
			if err != nil {
				return nil, fmt.Errorf("failed to scan price: %w", err)
			}
			prices = append(prices, p)
		}

		if err := rows.Err(); err != nil {
			return nil, fmt.Errorf("rows error: %w", err)
		}

		lt.Prices = prices

		landTokens = append(landTokens, lt)
	}
	return landTokens, nil
}

// LandToken is the resolver for the landToken field.
func (r *queryResolver) LandToken(ctx context.Context, landID int32) (*model.LandToken, error) {
	db := r.Database

	query := `
		SELECT name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
		FROM land_tokens
		WHERE land_id = ?;
	`
	row := db.QueryRowContext(ctx, query, landID)
	lt := &model.LandToken{}
	err := row.Scan(
		&lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
		&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
		&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("land token not found")
	} else if err != nil {
		return nil, fmt.Errorf("failed to scan land token: %w", err)
	}

	// Fetch prices for the land token
	query = `
	SELECT id, date, value
	FROM prices
	WHERE land_token_id = ?;
	`
	rows, err := db.QueryContext(ctx, query, lt.LandID)
	if err != nil {
		return nil, fmt.Errorf("failed to query prices: %w", err)
	}
	defer rows.Close()

	var prices []*model.Price
	for rows.Next() {
		p := &model.Price{}
		err := rows.Scan(&p.ID, &p.Date, &p.Value)
		if err != nil {
			return nil, fmt.Errorf("failed to scan price: %w", err)
		}
		prices = append(prices, p)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	lt.Prices = prices

	return lt, nil
}

// Sales is the resolver for the sales field.
func (r *queryResolver) Sales(ctx context.Context) ([]*model.Sale, error) {
	db := r.Database // Assuming r.Database is your *sql.DB

	query := `
		SELECT s.quantity, s.price, s.created_at, s.land_token_id, s.seller_id
		FROM sales s;
		`

	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query sales: %w", err)
	}
	defer rows.Close()

	var sales []*model.Sale
	for rows.Next() {
		s := &model.Sale{}
		var landTokenID int32
		var sellerID string
		err := rows.Scan(
			&s.Quantity, &s.Price, &s.CreatedAt, &landTokenID, &sellerID,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan sale: %w", err)
		}

		query := `
						SELECT land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
						FROM land_tokens
						WHERE land_id = ?;
		`
		row := db.QueryRowContext(ctx, query, landTokenID)
		lt := &model.LandToken{}
		err = row.Scan(
			&lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
			&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
			&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
		)

		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("land token not found")
		} else if err != nil {
			return nil, fmt.Errorf("failed to scan land token: %w", err)
		}

		// Fetch prices for the land token
		query = `
		SELECT id, date, value
		FROM prices
		WHERE land_token_id = ?;
		`

		rows, err := db.QueryContext(ctx, query, lt.LandID)
		if err != nil {
			return nil, fmt.Errorf("failed to query prices: %w", err)
		}
		defer rows.Close()

		var prices []*model.Price
		for rows.Next() {
			p := &model.Price{}
			err := rows.Scan(&p.ID, &p.Date, &p.Value)
			if err != nil {
				return nil, fmt.Errorf("failed to scan price: %w", err)
			}
			prices = append(prices, p)
		}

		if err := rows.Err(); err != nil {
			return nil, fmt.Errorf("rows error: %w", err)
		}

		lt.Prices = prices

		s.LandToken = lt

		query = `
			SELECT
				u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
				r.id, r.name, r.description
			FROM users u
			LEFT JOIN user_roles ur ON u.public_key = ur.user_public_key
			LEFT JOIN roles r ON ur.role_id = r.id
			WHERE u.public_key = ?
		`

		rows, err = db.QueryContext(ctx, query, sellerID)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch seller: %w", err)
		}
		defer rows.Close()

		var seller *model.User

		for rows.Next() {
			seller = &model.User{}
			role := &model.Role{}
			err := rows.Scan(&seller.PublicKey, &seller.Username, &seller.Email, &seller.Phone, &seller.CreatedAt, &seller.UpdatedAt, &role.ID, &role.Name, &role.Description)
			if err != nil {
				return nil, fmt.Errorf("failed to scan seller: %w", err)
			}
			seller.Roles = append(seller.Roles, role)
		}

		if seller == nil {
			return nil, fmt.Errorf("seller not found")
		}

		s.Seller = seller

		sales = append(sales, s)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return sales, nil
}

// Sale is the resolver for the sale field.
func (r *queryResolver) Sale(ctx context.Context, id int) (*model.Sale, error) {
	db := r.Database

	query := `
 		SELECT  s.quantity, s.price, s.created_at, s.land_token_id, s.seller_id
 		FROM sales s
 		WHERE s.id = ?;
 	`

	row := db.QueryRowContext(ctx, query, id)
	s := &model.Sale{}
	var landTokenID string
	var sellerID string
	err := row.Scan(
		&s.Quantity, &s.Price, &s.CreatedAt, &landTokenID, &sellerID,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("sale not found")
	} else if err != nil {
		return nil, fmt.Errorf("failed to scan sale: %w", err)
	}

	query = `
 		SELECT land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
 		FROM land_tokens
 		WHERE land_id = ?;
 	`
	row = db.QueryRowContext(ctx, query, landTokenID)
	lt := &model.LandToken{}
	err = row.Scan(
		&lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
		&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
		&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
	)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("land token not found")
	} else if err != nil {
		return nil, fmt.Errorf("failed to scan land token: %w", err)
	}

	query = `
 	SELECT id, date, value
 	FROM prices
 	WHERE land_token_id = ?;
 	`

	rows, err := db.QueryContext(ctx, query, lt.LandID)
	if err != nil {
		return nil, fmt.Errorf("failed to query prices: %w", err)
	}
	defer rows.Close()

	var prices []*model.Price
	for rows.Next() {
		p := &model.Price{}
		err := rows.Scan(&p.ID, &p.Date, &p.Value)
		if err != nil {
			return nil, fmt.Errorf("failed to scan price: %w", err)
		}
		prices = append(prices, p)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("rows error: %w", err)
	}

	lt.Prices = prices

	s.LandToken = lt

	query = `
 	SELECT
 	u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
 	r.id, r.name, r.description
 	FROM users u
 	LEFT JOIN user_roles ur ON u.public_key = ur.user_public_key
 	LEFT JOIN roles r ON ur.role_id = r.id
 	WHERE u.public_key = ?
 	`

	rows, err = db.QueryContext(ctx, query, sellerID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch seller: %w", err)
	}
	defer rows.Close()

	var seller *model.User

	for rows.Next() {
		seller = &model.User{}
		role := &model.Role{}
		err := rows.Scan(&seller.PublicKey, &seller.Username, &seller.Email, &seller.Phone, &seller.CreatedAt, &seller.UpdatedAt, &role.ID, &role.Name, &role.Description)
		if err != nil {
			return nil, fmt.Errorf("failed to scan seller: %w", err)
		}
		seller.Roles = append(seller.Roles, role)
	}

	if seller == nil {
		return nil, fmt.Errorf("seller not found")
	}

	s.Seller = seller

	return s, nil
}

// OwnedTokens is the resolver for the ownedTokens field.
func (r *queryResolver) OwnedTokens(ctx context.Context) ([]*model.OwnedToken, error) {
	gc, ok := ctx.Value(middleware.GinContextKey).(*gin.Context)
	if !ok {
		return nil, fmt.Errorf("can't get context")
	}

	userPublicKey := gc.GetString(string(middleware.UserContextKey))
	db := r.Database

	query := `
        SELECT
            ot.user_public_key,
            lt.land_id, lt.name, lt.total_tokens, lt.created_at AS land_created_at, lt.updated_at AS land_updated_at, lt.current_price,
            lt.property_type, lt.property_size, lt.property_size_unit, lt.landmark, lt.distance_from_landmark, lt.distance_unit,
            lt.property_description, lt.latitude, lt.longitude,
            ot.bought_price, ot.quantity, ot.created_at AS owned_at
        FROM owned_tokens ot
        JOIN land_tokens lt ON ot.land_token_id = lt.land_id
        WHERE ot.user_public_key = ?
    `

	rows, err := db.QueryContext(ctx, query, userPublicKey)
	if err != nil {
		return nil, fmt.Errorf("failed to query owned tokens: %w", err)
	}
	defer rows.Close()

	var ownedTokens []*model.OwnedToken
	for rows.Next() {
		ownedToken := &model.OwnedToken{}
		landToken := &model.LandToken{}

		err := rows.Scan(
			&ownedToken.UserPublicKey,
			&landToken.LandID, &landToken.Name, &landToken.TotalTokens, &landToken.CreatedAt, &landToken.UpdatedAt, &landToken.CurrentPrice,
			&landToken.PropertyType, &landToken.PropertySize, &landToken.PropertySizeUnit, &landToken.Landmark, &landToken.DistanceFromLandmark, &landToken.DistanceUnit,
			&landToken.PropertyDescription, &landToken.Latitude, &landToken.Longitude,
			&ownedToken.BoughtPrice, &ownedToken.Quantity, &ownedToken.CreatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan owned token: %w", err)
		}

		// Fetch prices for the current land token
		prices, err := r.fetchPricesForLandToken(ctx, db, landToken.LandID)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch prices for land token %d: %w", landToken.LandID, err)
		}
		landToken.Prices = prices
		ownedToken.LandToken = landToken
		ownedTokens = append(ownedTokens, ownedToken)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating owned tokens rows: %w", err)
	}

	return ownedTokens, nil
}

// TransactedTokens is the resolver for the transactedTokens field.
func (r *queryResolver) TransactedTokens(ctx context.Context) ([]*model.TransactedToken, error) {
	db := r.Database

	query := `
        SELECT
            tt.id,
            lt.land_id, lt.name, lt.total_tokens, lt.created_at AS land_created_at, lt.updated_at AS land_updated_at, lt.current_price,
            lt.property_type, lt.property_size, lt.property_size_unit, lt.landmark, lt.distance_from_landmark, lt.distance_unit,
            lt.property_description, lt.latitude, lt.longitude,
            tt.quantity, tt.price, tt.from_user, tt.to_user, tt.created_at
        FROM transacted_tokens tt
        JOIN land_tokens lt ON tt.land_token_id = lt.land_id
        ORDER BY tt.created_at DESC
    `

	rows, err := db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to query transacted tokens: %w", err)
	}
	defer rows.Close()

	var transactedTokens []*model.TransactedToken
	for rows.Next() {
		transactedToken := &model.TransactedToken{}
		landToken := &model.LandToken{}
		var fromUserPublicKey sql.NullString
		var toUserPublicKey sql.NullString

		err := rows.Scan(
			&transactedToken.ID,
			&landToken.LandID, &landToken.Name, &landToken.TotalTokens, &landToken.CreatedAt, &landToken.UpdatedAt, &landToken.CurrentPrice,
			&landToken.PropertyType, &landToken.PropertySize, &landToken.PropertySizeUnit, &landToken.Landmark, &landToken.DistanceFromLandmark, &landToken.DistanceUnit,
			&landToken.PropertyDescription, &landToken.Latitude, &landToken.Longitude,
			&transactedToken.Quantity, &transactedToken.Price, &fromUserPublicKey, &toUserPublicKey, &transactedToken.CreatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan transacted token: %w", err)
		}

		// Fetch prices for the land token
		prices, err := r.fetchPricesForLandToken(ctx, db, landToken.LandID)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch prices for land token %d: %w", landToken.LandID, err)
		}
		landToken.Prices = prices
		transactedToken.LandToken = landToken

		// Fetch 'from' user if available
		if fromUserPublicKey.Valid {
			fromUser, err := r.fetchUserByPublicKey(ctx, db, fromUserPublicKey.String)
			if err != nil {
				fmt.Printf("failed to fetch 'from' user %s: %v\n", fromUserPublicKey.String, err) // Log error, don't block all transactions
			}
			transactedToken.From = fromUser
		}

		// Fetch 'to' user if available
		if toUserPublicKey.Valid {
			toUser, err := r.fetchUserByPublicKey(ctx, db, toUserPublicKey.String)
			if err != nil {
				fmt.Printf("failed to fetch 'to' user %s: %v\n", toUserPublicKey.String, err) // Log error, don't block all transactions
			}
			transactedToken.To = toUser
		}

		transactedTokens = append(transactedTokens, transactedToken)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating transacted tokens rows: %w", err)
	}

	return transactedTokens, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func (r *queryResolver) fetchPricesForLandToken(ctx context.Context, db *sql.DB, landTokenID int32) ([]*model.Price, error) {
	query := `
        SELECT id, date, value
        FROM prices
        WHERE land_token_id = ?
        ORDER BY date DESC
    `
	rows, err := db.QueryContext(ctx, query, landTokenID)
	if err != nil {
		return nil, fmt.Errorf("failed to query prices for land token %d: %w", landTokenID, err)
	}
	defer rows.Close()

	var prices []*model.Price
	for rows.Next() {
		price := &model.Price{}
		var id int
		var date time.Time
		var value float64
		if err := rows.Scan(&id, &date, &value); err != nil {
			return nil, fmt.Errorf("failed to scan price for land token %d: %w", landTokenID, err)
		}
		price.ID = id
		price.Date = date
		price.Value = value
		prices = append(prices, price)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating prices rows for land token %d: %w", landTokenID, err)
	}

	return prices, nil
}
func (r *queryResolver) fetchUserByPublicKey(ctx context.Context, db *sql.DB, publicKey string) (*model.User, error) {
	query := `
        SELECT public_key, username, phone, email, created_at, updated_at
        FROM users
        WHERE public_key = ?
    `
	row := db.QueryRowContext(ctx, query, publicKey)

	user := &model.User{}
	err := row.Scan(&user.PublicKey, &user.Username, &user.Phone, &user.Email, &user.CreatedAt, &user.UpdatedAt)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil // User not found, which is acceptable for from/to users
		}
		return nil, fmt.Errorf("failed to scan user: %w", err)
	}

	// Fetch roles for the user (similar to your Login resolver)
	roles, err := r.fetchRolesForUser(ctx, db, publicKey)
	if err != nil {
		fmt.Printf("failed to fetch roles for user %s: %v\n", publicKey, err) // Log error, don't block user fetching
	}
	user.Roles = roles

	return user, nil
}
func (r *queryResolver) fetchRolesForUser(ctx context.Context, db *sql.DB, publicKey string) ([]*model.Role, error) {
	query := `
        SELECT r.id, r.name, r.description
        FROM users u
        LEFT JOIN user_roles ur ON u.public_key = ur.user_public_key
        LEFT JOIN roles r ON ur.role_id = r.id
        WHERE u.public_key = ?
    `
	rows, err := db.QueryContext(ctx, query, publicKey)
	if err != nil {
		return nil, fmt.Errorf("failed to query roles for user %s: %w", publicKey, err)
	}
	defer rows.Close()

	var roles []*model.Role
	for rows.Next() {
		role := &model.Role{}
		if err := rows.Scan(&role.ID, &role.Name, &role.Description); err != nil {
			return nil, fmt.Errorf("failed to scan role for user %s: %w", publicKey, err)
		}
		roles = append(roles, role)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating roles rows for user %s: %w", publicKey, err)
	}

	return roles, nil
}
