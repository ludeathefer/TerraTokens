// package graph

// // This file will be automatically regenerated based on the schema, any resolver implementations
// // will be copied through when generating and any unknown code will be moved to the end.
// // Code generated by github.com/99designs/gqlgen version v0.17.66

// import (
// 	"context"
// 	"database/sql"
// 	"fmt"
// 	"log"
// 	"math/big"
// 	"time"

// 	"github.com/ethereum/go-ethereum/common"
// 	"github.com/google/uuid"
// 	"github.com/ludeathfer/TerraTokens/backend/graph/model"
// 	"github.com/ludeathfer/TerraTokens/backend/middleware"
// 	blockchain "github.com/ludeathfer/TerraTokens/backend/pkg/go-eth"
// 	"golang.org/x/crypto/bcrypt"
// )

// // CreateUser is the resolver for the createUser field.
// func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
// 	db := r.Database

// 	// Start a transaction
// 	tx, err := db.BeginTx(ctx, nil)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to start transaction: %w", err)
// 	}

// 	// Ensure rollback on error
// 	defer func() {
// 		if err != nil {
// 			_ = tx.Rollback()
// 		}
// 	}()

// 	// Generate new UUID for user
// 	id := uuid.New()

// 	// Insert the user
// 	query := `
// 		INSERT INTO users (id, public_key, username, phone, email)
// 		VALUES (?, ?, ?, ?, ?)
// 	`
// 	_, err = tx.ExecContext(ctx, query, id.String(), input.PublicKey, input.Username, input.Phone, input.Email)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to insert user: %w", err)
// 	}

// 	// Fetch the 'user' role
// 	role := &model.Role{}
// 	query = `SELECT id, name, description FROM roles WHERE name = 'user'`
// 	err = tx.QueryRowContext(ctx, query).Scan(&role.ID, &role.Name, &role.Description)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch user role: %w", err)
// 	}

// 	// Assign the 'user' role to the new user
// 	query = `INSERT INTO user_roles (user_id, role_id) VALUES (?, ?)`
// 	_, err = tx.ExecContext(ctx, query, id.String(), role.ID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to assign user role: %w", err)
// 	}

// 	// Commit transaction
// 	if err = tx.Commit(); err != nil {
// 		return nil, fmt.Errorf("failed to commit transaction: %w", err)
// 	}

// 	// Return the created user object
// 	user := &model.User{
// 		ID:        id,
// 		PublicKey: input.PublicKey,
// 		Username:  input.Username,
// 		Phone:     input.Phone,
// 		Email:     input.Email,
// 		CreatedAt: time.Now(),
// 		UpdatedAt: time.Now(),
// 		Roles:     []*model.Role{role},
// 	}
// 	return user, nil
// }

// // UpdateUser is the resolver for the updateUser field.
// func (r *mutationResolver) UpdateUser(ctx context.Context, id uuid.UUID, input model.UpdateUserInput) (*model.User, error) {
// 	db := r.Database

// 	// Start a transaction
// 	tx, err := db.BeginTx(ctx, nil)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to start transaction: %w", err)
// 	}

// 	defer func() {
// 		if err != nil {
// 			tx.Rollback()
// 		}
// 	}()

// 	// Update query
// 	query := `
// 		UPDATE users
// 		SET updated_at = NOW()
// 		`
// 	args := []any{}

// 	if input.Username != nil {
// 		query += ", username = ?"
// 		args = append(args, input.Username)
// 	}

// 	if input.Phone != nil {
// 		query += ", phone = ?"
// 		args = append(args, input.Phone)
// 	}

// 	if input.Email != nil {
// 		query += ", email = ?"
// 		args = append(args, input.Email)
// 	}

// 	// Append password update only if provided
// 	if input.Password != nil {
// 		password := *input.Password

// 		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to hash password: %w", err)
// 		}

// 		query += ", password = ?"
// 		args = append(args, hashedPassword)
// 	}

// 	query += " WHERE id = ?"
// 	args = append(args, id.String())

// 	// Execute update
// 	result, err := tx.ExecContext(ctx, query, args...)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to update user: %w", err)
// 	}

// 	rowsAffected, err := result.RowsAffected()
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to check affected rows: %w", err)
// 	}

// 	if rowsAffected == 0 {
// 		return nil, fmt.Errorf("user not found")
// 	}

// 	// Commit transaction
// 	if err = tx.Commit(); err != nil {
// 		return nil, fmt.Errorf("failed to commit transaction: %w", err)
// 	}

// 	user := &model.User{
// 		ID:       id,
// 		Username: *input.Username,
// 		Phone:    *input.Phone,
// 		Email:    *input.Email,
// 	}

// 	return user, nil
// }

// // DeleteUser is the resolver for the deleteUser field.
// func (r *mutationResolver) DeleteUser(ctx context.Context, id uuid.UUID) (bool, error) {
// 	db := r.Database

// 	query := `DELETE FROM users WHERE id = ?`
// 	result, err := db.ExecContext(ctx, query, id.String())
// 	if err != nil {
// 		return false, fmt.Errorf("failed to delete user: %w", err)
// 	}

// 	rowsAffected, err := result.RowsAffected()
// 	if err != nil {
// 		return false, fmt.Errorf("failed to check affected rows: %w", err)
// 	}

// 	if rowsAffected == 0 {
// 		return false, fmt.Errorf("user not found")
// 	}

// 	return true, nil
// }

// // CreateLandToken is the resolver for the createLandToken field.
// func (r *mutationResolver) CreateLandToken(ctx context.Context, privateKey string, input model.CreateLandTokenInput) (*model.LandToken, error) {
// 	db := r.Database
// 	bcc := r.BlockchainClient

// 	transactor, err := blockchain.CreateTransactor(ctx, bcc.Client, privateKey)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed creating transactor: %v", err)
// 	}

// 	tx, err := bcc.Land.FractionalizeLand(transactor, "", big.NewInt(int64(input.TotalTokens)))
// 	if err != nil {
// 		return nil, fmt.Errorf("failed sending transaction: %v", err)
// 	}

// 	log.Printf("FractionalizeLand Transaction sent: %s", tx.Hash().Hex())

// 	userAddress := common.HexToAddress("f39Fd6e51aad88F6F4ce6aB8827279cffFb92266")
// 	tx, err = bcc.Land.TransferFractionalTokens(transactor, userAddress, big.NewInt(1), big.NewInt(int64(input.TotalTokens)))
// 	if err != nil {
// 		return nil, fmt.Errorf("failed transferring tokens: %v", err)
// 	}

// 	log.Printf("TransferFractionalTokens Transaction sent: %s", tx.Hash().Hex())

// 	eventLog, err := blockchain.WaitForEvent(ctx, bcc, tx.Hash().Hex())
// 	if err != nil {
// 		return nil, err
// 	}

// 	landIDBigInt := new(big.Int).SetBytes(eventLog.Topics[1].Bytes())
// 	landID := int32(landIDBigInt.Int64())

// 	// Generate new UUID
// 	landTokenID, _ := uuid.Parse("68cae590-18a9-48d5-beed-a084351d0fc4")

// 	// Insert data into DB
// 	query := `
// 			INSERT INTO land_tokens (
// 				id, land_id, name, total_tokens, current_price,
// 				property_type, property_size, property_size_unit, landmark,
// 				distance_from_landmark, distance_unit, property_description,
// 				latitude, longitude
// 			)
// 			VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )
// 		`
// 	_, err = db.ExecContext(ctx, query,
// 		landTokenID, landID, input.Name, input.TotalTokens, input.CurrentPrice,
// 		input.PropertyType, input.PropertySize, input.PropertySizeUnit, input.Landmark,
// 		input.DistanceFromLandmark, input.DistanceUnit, input.PropertyDescription,
// 		input.Latitude, input.Longitude,
// 	)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed inserting into database: %v", err)
// 	}

// 	// Construct response object
// 	landToken := &model.LandToken{
// 		ID:                   landTokenID,
// 		LandID:               landID,
// 		Name:                 input.Name,
// 		TotalTokens:          input.TotalTokens,
// 		CreatedAt:            time.Now(),
// 		UpdatedAt:            time.Now(),
// 		CurrentPrice:         input.CurrentPrice,
// 		PropertyType:         input.PropertyType,
// 		PropertySize:         input.PropertySize,
// 		PropertySizeUnit:     input.PropertySizeUnit,
// 		Landmark:             input.Landmark,
// 		DistanceFromLandmark: input.DistanceFromLandmark,
// 		DistanceUnit:         input.DistanceUnit,
// 		PropertyDescription:  input.PropertyDescription,
// 		Latitude:             input.Latitude,
// 		Longitude:            input.Longitude,
// 	}

// 	return landToken, nil
// }

// // UpdateLandToken is the resolver for the updateLandToken field.
// func (r *mutationResolver) UpdateLandToken(ctx context.Context, id uuid.UUID, input model.CreateLandTokenInput) (*model.LandToken, error) {
// 	panic(fmt.Errorf("not implemented: UpdateLandToken - updateLandToken"))
// }

// // AddPriceToLandToken is the resolver for the addPriceToLandToken field.
// func (r *mutationResolver) AddPriceToLandToken(ctx context.Context, landTokenID uuid.UUID, input model.CreatePriceInput) (*model.LandToken, error) {
// 	panic(fmt.Errorf("not implemented: AddPriceToLandToken - addPriceToLandToken"))
// }

// // BuyToken is the resolver for the buyToken field.
// func (r *mutationResolver) BuyToken(ctx context.Context, privateKey string, input model.BuyTokenInput) (*model.TransactedToken, error) {
// 	db := r.Database
// 	bcc := r.BlockchainClient

// 	transactor, err := blockchain.CreateTransactor(ctx, bcc.Client, privateKey)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed creating transactor: %v", err)
// 	}

// 	saleOrder := &blockchain.LandSaleOrder{}
// 	query := `
// 					SELECT lt.land_id, u.public_key, s.quantity, s.price, s.land_token_id, s.seller_id
// 					FROM sales s
// 					JOIN land_tokens lt ON s.land_token_id = lt.id
// 					JOIN users u ON s.seller_id = u.id
// 					WHERE s.id = ?;
// 	`
// 	var landTokenID, sellerID string
// 	err = db.QueryRowContext(ctx, query, input.SaleID).Scan(&saleOrder.LandId, &saleOrder.Seller, &saleOrder.Amount, &saleOrder.PricePerToken, &landTokenID, &sellerID)

// 	if err != nil {
// 		return nil, fmt.Errorf("failed fetching sale: %v", err)
// 	}

// 	saleOrders := []blockchain.LandSaleOrder{}
// 	saleOrders = append(saleOrders, *saleOrder)

// 	tx, err := bcc.Land.PurchaseTokens(transactor, saleOrder.LandId, saleOrders)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed sending transaction: %v", err)
// 	}

// 	log.Printf("PurchaseTokens Transaction sent: %s", tx.Hash().Hex())

// 	eventLog, err := blockchain.WaitForEvent(ctx, bcc, tx.Hash().Hex())
// 	if err != nil {
// 		return nil, err
// 	}

// 	amountBigInt := new(big.Int).SetBytes(eventLog.Topics[3].Bytes())
// 	amount := int32(amountBigInt.Int64())

// 	pricePerTokenBigInt := new(big.Int).SetBytes(eventLog.Topics[4].Bytes())
// 	pricePerToken := float64(pricePerTokenBigInt.Int64())

// 	ginCtx, err := GetGinContext(ctx)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to get Gin context: %w", err)
// 	}
// 	buyerID, ok := ginCtx.Get(string(middleware.UserContextKey))
// 	if !ok {
// 		return nil, fmt.Errorf("buyer ID not found in context")
// 	}
// 	buyerIDStr, ok := buyerID.(string)
// 	if !ok {
// 		return nil, fmt.Errorf("buyer ID is not a string")
// 	}

// 	// Update sales table
// 	updateSalesQuery := `UPDATE sales SET quantity = quantity - ? WHERE id = ?;`
// 	_, err = db.ExecContext(ctx, updateSalesQuery, amount, input.SaleID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to update sales table: %w", err)
// 	}

// 	//Update owned_tokens for buyer
// 	updateBuyerOwnedTokens := `
// 					INSERT INTO owned_tokens (user_id, land_token_id, quantity)
// 					VALUES (?, ?, ?)
// 					ON CONFLICT (user_id, land_token_id) DO UPDATE SET quantity = owned_tokens.quantity + ?;
// 	`
// 	_, err = db.ExecContext(ctx, updateBuyerOwnedTokens, buyerIDStr, landTokenID, amount, amount)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to update buyer owned_tokens: %w", err)
// 	}

// 	//Update owned_tokens for seller
// 	updateSellerOwnedTokens := `
// 					UPDATE owned_tokens SET quantity = quantity - ? WHERE user_id = ? AND land_token_id = ?;
// 	`
// 	_, err = db.ExecContext(ctx, updateSellerOwnedTokens, amount, sellerID, landTokenID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to update seller owned_tokens: %w", err)
// 	}

// 	//Insert into transacted_tokens and get the inserted ID
// 	var transactedTokenID int64
// 	insertTransactedTokens := `
// 					INSERT INTO transacted_tokens (land_token_id, quantity, price, from_user, to_user)
// 					VALUES (?, ?, ?, ?, ?)
// 					RETURNING id;
// 	`
// 	err = db.QueryRowContext(ctx, insertTransactedTokens, landTokenID, amount, pricePerToken, sellerID, buyerIDStr).Scan(&transactedTokenID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to insert into transacted_tokens and get ID: %w", err)
// 	}

// 	// Check if the sale quantity is now zero and delete the sale if it is.
// 	deleteSaleIfZero := `DELETE FROM sales WHERE id = ? AND quantity = 0;`
// 	_, err = db.ExecContext(ctx, deleteSaleIfZero, input.SaleID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to delete sale if quantity is zero: %w", err)
// 	}

// 	query = `
// 	SELECT id, land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
// 	FROM land_tokens
// 	WHERE id = ?;
// 	`
// 	row := db.QueryRowContext(ctx, query, landTokenID)
// 	lt := &model.LandToken{}
// 	err = row.Scan(
// 		&lt.ID, &lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
// 		&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
// 		&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
// 	)

// 	if err == sql.ErrNoRows {
// 		return nil, fmt.Errorf("land token not found")
// 	} else if err != nil {
// 		return nil, fmt.Errorf("failed to scan land token: %w", err)
// 	}

// 	// Fetch prices for the land token
// 	query = `
// 	SELECT id, date, value
// 	FROM prices
// 	WHERE land_token_id = ?;
// 	`

// 	rows, err := db.QueryContext(ctx, query, lt.ID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to query prices: %w", err)
// 	}
// 	defer rows.Close()

// 	var prices []*model.Price
// 	for rows.Next() {
// 		p := &model.Price{}
// 		err := rows.Scan(&p.ID, &p.Date, &p.Value)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan price: %w", err)
// 		}
// 		prices = append(prices, p)
// 	}

// 	if err := rows.Err(); err != nil {
// 		return nil, fmt.Errorf("rows error: %w", err)
// 	}

// 	lt.Prices = prices

// 	query = `
// 		SELECT
// 			u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 			r.id, r.name, r.description
// 		FROM users u
// 		LEFT JOIN user_roles ur ON u.id = ur.user_id
// 		LEFT JOIN roles r ON ur.role_id = r.id
// 		WHERE u.id = ?
// 	`

// 	rows, err = db.QueryContext(ctx, query, sellerID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch seller: %w", err)
// 	}
// 	defer rows.Close()

// 	var seller *model.User

// 	for rows.Next() {
// 		seller = &model.User{}
// 		role := &model.Role{}
// 		err := rows.Scan(&seller.ID, &seller.PublicKey, &seller.Username, &seller.Email, &seller.Phone, &seller.CreatedAt, &seller.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan seller: %w", err)
// 		}
// 		seller.Roles = append(seller.Roles, role)
// 	}

// 	if seller == nil {
// 		return nil, fmt.Errorf("seller not found")
// 	}

// 	rows, err = db.QueryContext(ctx, query, buyerID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch buyer: %w", err)
// 	}
// 	defer rows.Close()

// 	var buyer *model.User

// 	for rows.Next() {
// 		buyer = &model.User{}
// 		role := &model.Role{}
// 		err := rows.Scan(&buyer.ID, &buyer.PublicKey, &buyer.Username, &buyer.Email, &buyer.Phone, &buyer.CreatedAt, &buyer.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan buyer: %w", err)
// 		}
// 		buyer.Roles = append(buyer.Roles, role)
// 	}

// 	if buyer == nil {
// 		return nil, fmt.Errorf("seller not found")
// 	}

// 	return &model.TransactedToken{
// 		ID:        int(transactedTokenID),
// 		LandToken: lt,
// 		Quantity:  amount,
// 		Price:     pricePerToken,
// 		From:      seller,
// 		To:        buyer,
// 		CreatedAt: time.Now(),
// 	}, nil
// }

// // CreateSale is the resolver for the createSale field.
// func (r *mutationResolver) CreateSale(ctx context.Context, privateKey string, input model.CreateSaleInput) (*model.Sale, error) {
// 	db := r.Database
// 	bcc := r.BlockchainClient

// 	transactor, err := blockchain.CreateTransactor(ctx, bcc.Client, privateKey)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed creating transactor: %v", err)
// 	}

// 	query := `
// 					SELECT id, land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
// 					FROM land_tokens
// 					WHERE id = ?;
// 	`

// 	row := db.QueryRowContext(ctx, query, input.LandTokenID)
// 	lt := &model.LandToken{}
// 	err = row.Scan(
// 		&lt.ID, &lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
// 		&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
// 		&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
// 	)
// 	lt.LandID = 1

// 	if err == sql.ErrNoRows {
// 		return nil, fmt.Errorf("land token not found")
// 	} else if err != nil {
// 		return nil, fmt.Errorf("failed to scan land token: %w", err)
// 	}

// 	// Fetch prices for the land token
// 	query = `
// 	SELECT id, date, value
// 	FROM prices
// 	WHERE land_token_id = ?;
// 	`
// 	rows, err := db.QueryContext(ctx, query, lt.ID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to query prices: %w", err)
// 	}
// 	defer rows.Close()

// 	var prices []*model.Price
// 	for rows.Next() {
// 		p := &model.Price{}
// 		err := rows.Scan(&p.ID, &p.Date, &p.Value)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan price: %w", err)
// 		}
// 		prices = append(prices, p)
// 	}

// 	if err := rows.Err(); err != nil {
// 		return nil, fmt.Errorf("rows error: %w", err)
// 	}

// 	lt.Prices = prices

// 	tx, err := bcc.Land.ListTokensForSale(transactor, big.NewInt(int64(lt.LandID)), big.NewInt(int64(input.Quantity)), big.NewInt(int64(input.Price)))
// 	if err != nil {
// 		return nil, fmt.Errorf("failed sending transaction: %v", err)
// 	}

// 	log.Printf("ListTokensForSale Transaction sent: %s", tx.Hash().Hex())

// 	_, err = blockchain.WaitForEvent(ctx, bcc, tx.Hash().Hex())
// 	if err != nil {
// 		return nil, err
// 	}

// 	ginCtx, err := GetGinContext(ctx)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to get Gin context: %w", err)
// 	}
// 	userID, ok := ginCtx.Get(string(middleware.UserContextKey))
// 	if !ok {
// 		return nil, fmt.Errorf("user ID not found in context")
// 	}
// 	userIDStr, ok := userID.(string)
// 	if !ok {
// 		return nil, fmt.Errorf("user ID is not a string")
// 	}

// 	insertSaleQuery := `
// 					INSERT INTO sales (land_token_id, quantity, price, seller_id)
// 					VALUES (?, ?, ?, ?)
// 					RETURNING id, created_at;
// 	`

// 	var saleID int
// 	var createdAt time.Time
// 	err = db.QueryRowContext(ctx, insertSaleQuery, lt.ID, input.Quantity, input.Price, userIDStr).Scan(&saleID, &createdAt)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to insert sale into the database: %w", err)
// 	}

// 	query = `
// 	SELECT
// 		u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 		r.id, r.name, r.description
// 	FROM users u
// 	LEFT JOIN user_roles ur ON u.id = ur.user_id
// 	LEFT JOIN roles r ON ur.role_id = r.id
// 	WHERE u.id = ?
// `

// 	rows, err = db.QueryContext(ctx, query, userID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch seller: %w", err)
// 	}
// 	defer rows.Close()

// 	var seller *model.User

// 	for rows.Next() {
// 		seller = &model.User{}
// 		role := &model.Role{}
// 		err := rows.Scan(&seller.ID, &seller.PublicKey, &seller.Username, &seller.Email, &seller.Phone, &seller.CreatedAt, &seller.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan seller: %w", err)
// 		}
// 		seller.Roles = append(seller.Roles, role)
// 	}

// 	if seller == nil {
// 		return nil, fmt.Errorf("seller not found")
// 	}

// 	return &model.Sale{
// 		ID:        saleID,
// 		LandToken: lt,
// 		Quantity:  input.Quantity,
// 		Price:     input.Price,
// 		Seller:    seller,
// 		CreatedAt: createdAt,
// 	}, nil
// }

// // UpdateSale is the resolver for the updateSale field.
// func (r *mutationResolver) UpdateSale(ctx context.Context, privateKey string, id uuid.UUID, input model.UpdateSaleInput) (*model.Sale, error) {
// 	db := r.Database
// 	bcc := r.BlockchainClient

// 	transactor, err := blockchain.CreateTransactor(ctx, bcc.Client, privateKey)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed creating transactor: %v", err)
// 	}

// 	query := `
// 	SELECT s.id, s.quantity, s.price, s.created_at, s.land_id, s.seller_id
// 	FROM sales s
// 	WHERE s.id = ?;
// `

// 	row := db.QueryRowContext(ctx, query, id)
// 	s := &model.Sale{}
// 	var landID int
// 	var sellerID string
// 	err = row.Scan(
// 		&s.ID, &s.Quantity, &s.Price, &s.CreatedAt, &landID, &sellerID,
// 	)

// 	if err == sql.ErrNoRows {
// 		return nil, fmt.Errorf("sale not found") // Sale not found
// 	} else if err != nil {
// 		return nil, fmt.Errorf("failed to scan sale: %w", err)
// 	}

// 	tx, err := bcc.Land.UpdateTokenListing(transactor, big.NewInt(int64(landID)), big.NewInt(int64(input.Quantity)), big.NewInt(int64(input.Price)))
// 	if err != nil {
// 		return nil, fmt.Errorf("failed sending transaction: %v", err)
// 	}

// 	log.Printf("UpdateTokenListing Transaction sent: %s", tx.Hash().Hex())

// 	_, err = blockchain.WaitForEvent(ctx, bcc, tx.Hash().Hex())
// 	if err != nil {
// 		return nil, err
// 	}

// 	updateSaleQuery := `
// 		UPDATE sales
// 		SET quantity = ?, price = ?
// 		WHERE id = ?;
// `

// 	_, err = db.ExecContext(ctx, updateSaleQuery, input.Quantity, input.Price, id)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to update sale in the database: %w", err)
// 	}

// 	query = `
// 					SELECT id, land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
// 					FROM land_tokens
// 					WHERE id = ?;
// 	`

// 	row = db.QueryRowContext(ctx, query, id)
// 	lt := &model.LandToken{}
// 	err = row.Scan(
// 		&lt.ID, &lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
// 		&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
// 		&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
// 	)

// 	if err == sql.ErrNoRows {
// 		return nil, fmt.Errorf("land token not found")
// 	} else if err != nil {
// 		return nil, fmt.Errorf("failed to scan land token: %w", err)
// 	}

// 	// Fetch prices for the land token
// 	query = `
// 	SELECT id, date, value
// 	FROM prices
// 	WHERE land_token_id = ?;
// 	`
// 	rows, err := db.QueryContext(ctx, query, lt.ID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to query prices: %w", err)
// 	}
// 	defer rows.Close()

// 	var prices []*model.Price
// 	for rows.Next() {
// 		p := &model.Price{}
// 		err := rows.Scan(&p.ID, &p.Date, &p.Value)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan price: %w", err)
// 		}
// 		prices = append(prices, p)
// 	}

// 	if err := rows.Err(); err != nil {
// 		return nil, fmt.Errorf("rows error: %w", err)
// 	}

// 	lt.Prices = prices

// 	query = `
// 	SELECT
// 		u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 		r.id, r.name, r.description
// 	FROM users u
// 	LEFT JOIN user_roles ur ON u.id = ur.user_id
// 	LEFT JOIN roles r ON ur.role_id = r.id
// 	WHERE u.id = ?
// `

// 	rows, err = db.QueryContext(ctx, query, sellerID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch seller: %w", err)
// 	}
// 	defer rows.Close()

// 	var seller *model.User

// 	for rows.Next() {
// 		seller = &model.User{}
// 		role := &model.Role{}
// 		err := rows.Scan(&seller.ID, &seller.PublicKey, &seller.Username, &seller.Email, &seller.Phone, &seller.CreatedAt, &seller.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan seller: %w", err)
// 		}
// 		seller.Roles = append(seller.Roles, role)
// 	}

// 	if seller == nil {
// 		return nil, fmt.Errorf("seller not found")
// 	}

// 	s.Quantity = input.Quantity
// 	s.Price = input.Price
// 	s.LandToken = lt
// 	s.Seller = seller

// 	return s, nil
// }

// // DeleteSale is the resolver for the deleteSale field.
// func (r *mutationResolver) DeleteSale(ctx context.Context, privateKey string, id int) (bool, error) {
// 	db := r.Database
// 	bcc := r.BlockchainClient

// 	transactor, err := blockchain.CreateTransactor(ctx, bcc.Client, privateKey)
// 	if err != nil {
// 		return false, fmt.Errorf("failed creating transactor: %v", err)
// 	}

// 	query := `
// 					SELECT s.id, s.quantity, s.price, s.created_at, lt.land_id, s.seller_id
// 					FROM sales s
// 					JOIN land_tokens lt ON s.land_token_id = lt.id
// 					WHERE s.id = ?;
// 	`

// 	row := db.QueryRowContext(ctx, query, id)
// 	s := &model.Sale{}
// 	var landID int
// 	var sellerID string
// 	err = row.Scan(
// 		&s.ID, &s.Quantity, &s.Price, &s.CreatedAt, &landID, &sellerID,
// 	)

// 	if err == sql.ErrNoRows {
// 		return false, fmt.Errorf("sale not found")
// 	} else if err != nil {
// 		return false, fmt.Errorf("failed to scan sale: %w", err)
// 	}

// 	tx, err := bcc.Land.CancelTokenListing(transactor, big.NewInt(int64(landID)), big.NewInt(int64(s.Quantity)), big.NewInt(int64(s.Price)))
// 	if err != nil {
// 		return false, fmt.Errorf("failed sending transaction: %v", err)
// 	}

// 	log.Printf("CancelTokenListing Transaction sent: %s", tx.Hash().Hex())

// 	_, err = blockchain.WaitForEvent(ctx, bcc, tx.Hash().Hex())
// 	if err != nil {
// 		return false, err
// 	}

// 	deleteSaleQuery := `
// 					DELETE FROM sales
// 					WHERE id = ?;
// 	`

// 	_, err = db.ExecContext(ctx, deleteSaleQuery, id)
// 	if err != nil {
// 		return false, fmt.Errorf("failed to delete sale from the database: %w", err)
// 	}

// 	return true, nil
// }

// // AddToWatchlist is the resolver for the addToWatchlist field.
// func (r *mutationResolver) AddToWatchlist(ctx context.Context, landTokenID uuid.UUID) (*model.User, error) {
// 	db := r.Database
// 	ginCtx, err := GetGinContext(ctx)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to get Gin context: %w", err)
// 	}
// 	userID, ok := ginCtx.Get(string(middleware.UserContextKey))
// 	if !ok {
// 		return nil, fmt.Errorf("buyer ID not found in context")
// 	}
// 	userIDStr, ok := userID.(string)
// 	if !ok {
// 		return nil, fmt.Errorf("buyer ID is not a string")
// 	}

// 	query := `
// 					INSERT INTO watchlist (user_id, land_token_id)
// 					VALUES (?, ?)
// 					ON CONFLICT (user_id, land_token_id) DO NOTHING;
// 	`

// 	_, err = db.ExecContext(ctx, query, userIDStr, landTokenID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to add to watchlist: %w", err)
// 	}

// 	query = `
// 		SELECT
// 			u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 			r.id, r.name, r.description
// 		FROM users u
// 		LEFT JOIN user_roles ur ON u.id = ur.user_id
// 		LEFT JOIN roles r ON ur.role_id = r.id
// 		WHERE u.id = ?
// 	`

// 	rows, err := db.QueryContext(ctx, query, userID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch user: %w", err)
// 	}
// 	defer rows.Close()

// 	var user *model.User

// 	for rows.Next() {
// 		user = &model.User{}
// 		role := &model.Role{}
// 		err := rows.Scan(&user.ID, &user.PublicKey, &user.Username, &user.Email, &user.Phone, &user.CreatedAt, &user.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan user: %w", err)
// 		}
// 		user.Roles = append(user.Roles, role)
// 	}

// 	if user == nil {
// 		return nil, fmt.Errorf("user not found")
// 	}

// 	return user, nil
// }

// // RemoveFromWatchlist is the resolver for the removeFromWatchlist field.
// func (r *mutationResolver) RemoveFromWatchlist(ctx context.Context, landTokenID uuid.UUID) (*model.User, error) {
// 	db := r.Database
// 	ginCtx, err := GetGinContext(ctx)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to get Gin context: %w", err)
// 	}
// 	userID, ok := ginCtx.Get(string(middleware.UserContextKey))
// 	if !ok {
// 		return nil, fmt.Errorf("buyer ID not found in context")
// 	}
// 	userIDStr, ok := userID.(string)
// 	if !ok {
// 		return nil, fmt.Errorf("buyer ID is not a string")
// 	}

// 	query := `
// 					DELETE FROM watchlist
// 					WHERE user_id = ? AND land_token_id = ?;
// 	`

// 	_, err = db.ExecContext(ctx, query, userIDStr, landTokenID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to remove from watchlist: %w", err)
// 	}

// 	query = `
// 		SELECT
// 			u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 			r.id, r.name, r.description
// 		FROM users u
// 		LEFT JOIN user_roles ur ON u.id = ur.user_id
// 		LEFT JOIN roles r ON ur.role_id = r.id
// 		WHERE u.id = ?
// 	`

// 	rows, err := db.QueryContext(ctx, query, userID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch user: %w", err)
// 	}
// 	defer rows.Close()

// 	var user *model.User

// 	for rows.Next() {
// 		user = &model.User{}
// 		role := &model.Role{}
// 		err := rows.Scan(&user.ID, &user.PublicKey, &user.Username, &user.Email, &user.Phone, &user.CreatedAt, &user.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan user: %w", err)
// 		}
// 		user.Roles = append(user.Roles, role)
// 	}

// 	if user == nil {
// 		return nil, fmt.Errorf("user not found")
// 	}

// 	return user, nil
// }

// // Users is the resolver for the users field.
// func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
// 	db := r.Database

// 	query :=
// 		`
// 		select u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 		r.id, r.name, r.description
// 		from users u
// 		left join user_roles ur on u.id = ur.user_id
// 		left join roles r on ur.role_id = r.id
// 		`

// 	rows, err := db.QueryContext(ctx, query)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch users: %w", err)
// 	}
// 	defer rows.Close()

// 	userMap := make(map[uuid.UUID]*model.User)

// 	for rows.Next() {
// 		user := &model.User{}
// 		role := &model.Role{}

// 		err := rows.Scan(&user.ID, &user.PublicKey, &user.Username, &user.Phone, &user.Email, &user.CreatedAt, &user.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan user: %w", err)
// 		}

// 		if _, exists := userMap[user.ID]; !exists {
// 			userMap[user.ID] = user
// 		}

// 		userMap[user.ID].Roles = append(userMap[user.ID].Roles, role)
// 	}

// 	users := make([]*model.User, 0, len(userMap))
// 	for _, user := range userMap {
// 		users = append(users, user)
// 	}

// 	return users, nil
// }

// // User is the resolver for the user field.
// func (r *queryResolver) User(ctx context.Context, id uuid.UUID) (*model.User, error) {
// 	db := r.Database

// 	query := `
// 		SELECT
// 			u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 			r.id, r.name, r.description
// 		FROM users u
// 		LEFT JOIN user_roles ur ON u.id = ur.user_id
// 		LEFT JOIN roles r ON ur.role_id = r.id
// 		WHERE u.id = ?
// 	`

// 	rows, err := db.QueryContext(ctx, query, id.String())
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch user: %w", err)
// 	}
// 	defer rows.Close()

// 	var user *model.User

// 	for rows.Next() {
// 		user = &model.User{}
// 		role := &model.Role{}
// 		err := rows.Scan(&user.ID, &user.PublicKey, &user.Username, &user.Email, &user.Phone, &user.CreatedAt, &user.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan user: %w", err)
// 		}
// 		user.Roles = append(user.Roles, role)
// 	}

// 	if user == nil {
// 		return nil, fmt.Errorf("user not found")
// 	}

// 	return user, nil
// }

// // Login is the resolver for the login field.
// func (r *queryResolver) Login(ctx context.Context, publicKey string) (*model.LoginResponse, error) {
// 	db := r.Database

// 	query := `
// 				SELECT
// 					u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 					r.id, r.name, r.description
// 				FROM users u
// 				LEFT JOIN user_roles ur ON u.id = ur.user_id
// 				LEFT JOIN roles r ON ur.role_id = r.id
// 				WHERE u.public_key = ?
// 			`
// 	rows, err := db.QueryContext(ctx, query, publicKey)
// 	if err != nil {
// 		return nil, fmt.Errorf("invalid credentials: %w", err)
// 	}
// 	defer rows.Close()

// 	var user *model.User
// 	roleNames := []string{}
// 	for rows.Next() {
// 		user = &model.User{}
// 		role := &model.Role{}
// 		err := rows.Scan(&user.ID, &user.PublicKey, &user.Username, &user.Email, &user.Phone, &user.CreatedAt, &user.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan user: %w", err)
// 		}
// 		user.Roles = append(user.Roles, role)
// 		roleNames = append(roleNames, role.Name)
// 	}

// 	if user == nil {
// 		return nil, fmt.Errorf("invalid credentials")
// 	}

// 	token, err := middleware.GenerateToken(r.Config.JWT, user.ID, roleNames)
// 	if err != nil {
// 		return nil, err
// 	}

// 	loginResponse := &model.LoginResponse{
// 		Token: token,
// 		User:  user,
// 	}

// 	return loginResponse, nil
// }

// // LandTokens is the resolver for the landTokens field.
// func (r *queryResolver) LandTokens(ctx context.Context) ([]*model.LandToken, error) {
// 	db := r.Database // Assuming r.Database is your *sql.DB

// 	query := `
// 					SELECT id, land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
// 					FROM land_tokens;
// 	`

// 	rows, err := db.QueryContext(ctx, query)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to query land tokens: %w", err)
// 	}
// 	defer rows.Close()

// 	var landTokens []*model.LandToken
// 	for rows.Next() {
// 		lt := &model.LandToken{}
// 		err := rows.Scan(
// 			&lt.ID, &lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
// 			&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
// 			&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
// 		)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan land token: %w", err)
// 		}

// 		// Fetch prices for the land token
// 		query := `
// 					SELECT id, date, value
// 					FROM prices
// 					WHERE land_token_id = ?;
// 	`

// 		rows, err := db.QueryContext(ctx, query, lt.ID)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to query prices: %w", err)
// 		}
// 		defer rows.Close()

// 		var prices []*model.Price
// 		for rows.Next() {
// 			p := &model.Price{}
// 			err := rows.Scan(&p.ID, &p.Date, &p.Value)
// 			if err != nil {
// 				return nil, fmt.Errorf("failed to scan price: %w", err)
// 			}
// 			prices = append(prices, p)
// 		}

// 		if err := rows.Err(); err != nil {
// 			return nil, fmt.Errorf("rows error: %w", err)
// 		}

// 		lt.Prices = prices

// 		landTokens = append(landTokens, lt)
// 	}

// 	return landTokens, nil
// }

// // LandToken is the resolver for the landToken field.
// func (r *queryResolver) LandToken(ctx context.Context, id uuid.UUID) (*model.LandToken, error) {
// 	db := r.Database

// 	query := `
// 					SELECT id, land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
// 					FROM land_tokens
// 					WHERE id = ?;
// 	`

// 	row := db.QueryRowContext(ctx, query, id)
// 	lt := &model.LandToken{}
// 	err := row.Scan(
// 		&lt.ID, &lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
// 		&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
// 		&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
// 	)

// 	if err == sql.ErrNoRows {
// 		return nil, fmt.Errorf("land token not found")
// 	} else if err != nil {
// 		return nil, fmt.Errorf("failed to scan land token: %w", err)
// 	}

// 	// Fetch prices for the land token
// 	query = `
// 	SELECT id, date, value
// 	FROM prices
// 	WHERE land_token_id = ?;
// 	`
// 	rows, err := db.QueryContext(ctx, query, lt.ID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to query prices: %w", err)
// 	}
// 	defer rows.Close()

// 	var prices []*model.Price
// 	for rows.Next() {
// 		p := &model.Price{}
// 		err := rows.Scan(&p.ID, &p.Date, &p.Value)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan price: %w", err)
// 		}
// 		prices = append(prices, p)
// 	}

// 	if err := rows.Err(); err != nil {
// 		return nil, fmt.Errorf("rows error: %w", err)
// 	}

// 	lt.Prices = prices

// 	return lt, nil
// }

// // Sales is the resolver for the sales field.
// func (r *queryResolver) Sales(ctx context.Context) ([]*model.Sale, error) {
// 	db := r.Database // Assuming r.Database is your *sql.DB

// 	query := `
// 					SELECT s.id, s.quantity, s.price, s.created_at, s.land_token_id, s.seller_id
// 					FROM sales s;
// 	`

// 	rows, err := db.QueryContext(ctx, query)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to query sales: %w", err)
// 	}
// 	defer rows.Close()

// 	var sales []*model.Sale
// 	for rows.Next() {
// 		s := &model.Sale{}
// 		var landTokenID string
// 		var sellerID string
// 		err := rows.Scan(
// 			&s.ID, &s.Quantity, &s.Price, &s.CreatedAt, &landTokenID, &sellerID,
// 		)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan sale: %w", err)
// 		}

// 		query := `
// 					SELECT id, land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
// 					FROM land_tokens
// 					WHERE id = ?;
// 	`
// 		row := db.QueryRowContext(ctx, query, landTokenID)
// 		lt := &model.LandToken{}
// 		err = row.Scan(
// 			&lt.ID, &lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
// 			&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
// 			&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
// 		)

// 		if err == sql.ErrNoRows {
// 			return nil, fmt.Errorf("land token not found")
// 		} else if err != nil {
// 			return nil, fmt.Errorf("failed to scan land token: %w", err)
// 		}

// 		// Fetch prices for the land token
// 		query = `
// 	SELECT id, date, value
// 	FROM prices
// 	WHERE land_token_id = ?;
// 	`

// 		rows, err := db.QueryContext(ctx, query, lt.ID)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to query prices: %w", err)
// 		}
// 		defer rows.Close()

// 		var prices []*model.Price
// 		for rows.Next() {
// 			p := &model.Price{}
// 			err := rows.Scan(&p.ID, &p.Date, &p.Value)
// 			if err != nil {
// 				return nil, fmt.Errorf("failed to scan price: %w", err)
// 			}
// 			prices = append(prices, p)
// 		}

// 		if err := rows.Err(); err != nil {
// 			return nil, fmt.Errorf("rows error: %w", err)
// 		}

// 		lt.Prices = prices

// 		s.LandToken = lt

// 		query = `
// 		SELECT
// 			u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 			r.id, r.name, r.description
// 		FROM users u
// 		LEFT JOIN user_roles ur ON u.id = ur.user_id
// 		LEFT JOIN roles r ON ur.role_id = r.id
// 		WHERE u.id = ?
// 	`

// 		rows, err = db.QueryContext(ctx, query, sellerID)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to fetch seller: %w", err)
// 		}
// 		defer rows.Close()

// 		var seller *model.User

// 		for rows.Next() {
// 			seller = &model.User{}
// 			role := &model.Role{}
// 			err := rows.Scan(&seller.ID, &seller.PublicKey, &seller.Username, &seller.Email, &seller.Phone, &seller.CreatedAt, &seller.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 			if err != nil {
// 				return nil, fmt.Errorf("failed to scan seller: %w", err)
// 			}
// 			seller.Roles = append(seller.Roles, role)
// 		}

// 		if seller == nil {
// 			return nil, fmt.Errorf("seller not found")
// 		}

// 		s.Seller = seller

// 		sales = append(sales, s)
// 	}

// 	if err := rows.Err(); err != nil {
// 		return nil, fmt.Errorf("rows error: %w", err)
// 	}

// 	return sales, nil
// }

// // Sale is the resolver for the sale field.
// func (r *queryResolver) Sale(ctx context.Context, id int) (*model.Sale, error) {
// 	db := r.Database

// 	query := `
// 		SELECT s.id, s.quantity, s.price, s.created_at, s.land_token_id, s.seller_id
// 		FROM sales s
// 		WHERE s.id = ?;
// 	`

// 	row := db.QueryRowContext(ctx, query, id)
// 	s := &model.Sale{}
// 	var landTokenID string
// 	var sellerID string
// 	err := row.Scan(
// 		&s.ID, &s.Quantity, &s.Price, &s.CreatedAt, &landTokenID, &sellerID,
// 	)

// 	if err == sql.ErrNoRows {
// 		return nil, fmt.Errorf("sale not found") // Sale not found
// 	} else if err != nil {
// 		return nil, fmt.Errorf("failed to scan sale: %w", err)
// 	}

// 	query = `
// 		SELECT id, land_id, name, total_tokens, created_at, updated_at, current_price, property_type, property_size, property_size_unit, landmark, distance_from_landmark, distance_unit, property_description, latitude, longitude
// 		FROM land_tokens
// 		WHERE id = ?;
// 	`
// 	row = db.QueryRowContext(ctx, query, landTokenID)
// 	lt := &model.LandToken{}
// 	err = row.Scan(
// 		&lt.ID, &lt.LandID, &lt.Name, &lt.TotalTokens, &lt.CreatedAt, &lt.UpdatedAt, &lt.CurrentPrice,
// 		&lt.PropertyType, &lt.PropertySize, &lt.PropertySizeUnit, &lt.Landmark, &lt.DistanceFromLandmark,
// 		&lt.DistanceUnit, &lt.PropertyDescription, &lt.Latitude, &lt.Longitude,
// 	)

// 	if err == sql.ErrNoRows {
// 		return nil, fmt.Errorf("land token not found")
// 	} else if err != nil {
// 		return nil, fmt.Errorf("failed to scan land token: %w", err)
// 	}

// 	// Fetch prices for the land token
// 	query = `
// 	SELECT id, date, value
// 	FROM prices
// 	WHERE land_token_id = ?;
// 	`

// 	rows, err := db.QueryContext(ctx, query, lt.ID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to query prices: %w", err)
// 	}
// 	defer rows.Close()

// 	var prices []*model.Price
// 	for rows.Next() {
// 		p := &model.Price{}
// 		err := rows.Scan(&p.ID, &p.Date, &p.Value)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan price: %w", err)
// 		}
// 		prices = append(prices, p)
// 	}

// 	if err := rows.Err(); err != nil {
// 		return nil, fmt.Errorf("rows error: %w", err)
// 	}

// 	lt.Prices = prices

// 	s.LandToken = lt

// 	query = `
// 	SELECT
// 	u.id, u.public_key, u.username, u.phone, u.email, u.created_at, u.updated_at,
// 	r.id, r.name, r.description
// 	FROM users u
// 	LEFT JOIN user_roles ur ON u.id = ur.user_id
// 	LEFT JOIN roles r ON ur.role_id = r.id
// 	WHERE u.id = ?
// 	`

// 	rows, err = db.QueryContext(ctx, query, sellerID)
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to fetch seller: %w", err)
// 	}
// 	defer rows.Close()

// 	var seller *model.User

// 	for rows.Next() {
// 		seller = &model.User{}
// 		role := &model.Role{}
// 		err := rows.Scan(&seller.ID, &seller.PublicKey, &seller.Username, &seller.Email, &seller.Phone, &seller.CreatedAt, &seller.UpdatedAt, &role.ID, &role.Name, &role.Description)
// 		if err != nil {
// 			return nil, fmt.Errorf("failed to scan seller: %w", err)
// 		}
// 		seller.Roles = append(seller.Roles, role)
// 	}

// 	if seller == nil {
// 		return nil, fmt.Errorf("seller not found")
// 	}

// 	s.Seller = seller

// 	return s, nil
// }

// // Mutation returns MutationResolver implementation.
// func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// // Query returns QueryResolver implementation.
// func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// type mutationResolver struct{ *Resolver }
// type queryResolver struct{ *Resolver }